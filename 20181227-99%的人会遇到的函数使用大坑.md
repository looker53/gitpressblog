---
layout: post
title: python的函数定义中99%的人会遇到的一个坑
date: 2018-12-27 21:51:33
tags: 编程
---


列表是一种经常使用的数据类型。在函数的定义中，常常会使用列表作为参数。v方法v

比如，要测试一个接口的数据，接口返回的数据格式如下：

```json
{
  "code": "20000", 
  "data": ["孙悟空","李白","甄姬"], 
  "msg": "success", 
  "status": 0
}
```

要测试的内容是：返回的 data 数据是否跟需求符合。在测试之前，需要对数据进一步处理，比如要增加 "王昭君" 这个元素进去，需要写一个函数：

```python
def add_element(data=["孙悟空","李白","甄姬"]):
    data.append('王昭君')
    return data

print(add_element())
print(add_element())
print(add_element())
```

在函数定义的时候经常会给参数设置默认值，在这个例子中，将 data 参数设置了默认值，函数定义以后，后面会被频繁的调用，期望值应该是打印如下：

```python
["孙悟空","李白","甄姬","王昭君"]
["孙悟空","李白","甄姬","王昭君"]
["孙悟空","李白","甄姬","王昭君"]
```

实际结果为：

```python
["孙悟空","李白","甄姬","王昭君"]
["孙悟空","李白","甄姬","王昭君","王昭君"]
["孙悟空","李白","甄姬","王昭君","王昭君","王昭君"]
```

### 原因

当定义函数时，会保存函数中默认参数 data 的值，也就是 `["孙悟空","李白","甄姬"]`,在每次调用的时候如果传递了新的实参，则使用传递的参数；没有传递，使用定义函数时保存的默认参数。

上面两次调用中，都没有传递新的实参，程序会调用定义函数时保存的默认参数，因为 append() , 在第一次调用以后，默认参数已经由 `["孙悟空","李白","甄姬"]` 改变为 `["孙悟空","李白","甄姬","王昭君"]`,再次执行 append() 之后，就变成了 `["孙悟空","李白","甄姬","王昭君","王昭君"]`；同理，第三次又改变了。

可以使用 id() 函数来定位问题：

```python
def add_element(data=["孙悟空","李白","甄姬"]):
    # id 来表示是不是同一个对象
	print(id(data))
    data.append('王昭君')
    return data

print(add_element())
print(add_element())
print(add_element())
```

打印出来的 `id(data)` 为同一个对象，也就是默认参数。如果我们改变 第二个 `print(add_element()) `为 `print(add_element(["孙悟空","李白","甄姬"]))`，那么第 2 个 `id(data)` 就会发生变化，因为它不在是默认值，而是新传进来的实参，实际结果也将变成：

```python
2543416926792
['孙悟空', '李白', '甄姬', '王昭君']
2543418907848
["孙悟空","李白","甄姬", '王昭君']
2543416926792
['孙悟空', '李白', '甄姬', '王昭君', '王昭君']
```

### 改进方案

- 如果参数中有列表，尽量不要用它做默认参数
- 如果使用了列表作为默认参数，函数调用时传入实参，而不是省略
- 可以在函数体中另外定义一个变量接收默认参数

```python
def add_element(data=["孙悟空","李白","甄姬"]):
    if data == ["孙悟空","李白","甄姬"]:
        data = ["孙悟空","李白","甄姬"]
    data.append('王昭君')
    return data
```

